import 'dart:io';

import 'package:cli_util/cli_logging.dart';
import 'package:fast_flutter_driver_tool/src/preparing_tests/file_system.dart';
import 'package:meta/meta.dart';
import 'package:path/path.dart' as p;

const aggregatedTestFile = 'generic_test.dart';
const setupMainFile = 'generic.dart';

class TestFileProvider {
  const TestFileProvider({@required this.logger});

  final Logger logger;

  Future<String> testFile(String path) async {
    if (Directory(path).existsSync()) {
      return aggregatedTest(path, TestGenerator(), logger);
    } else if (File(path).existsSync()) {
      return path;
    }
    return null;
  }
}

Future<String> aggregatedTest(
  String directoryPath,
  TestGenerator generator,
  Logger logger,
) async {
  final dir = Directory(directoryPath);
  final setupFile = dir.findOrNull(
        setupMainFile,
        recursive: true,
      ) ??
      Directory.current.findOrNull(
        setupMainFile,
        recursive: true,
      );
  if (setupFile == null) {
    return null;
  }
  final genericTestFile =
      File(platformPath(p.join(p.dirname(setupFile), aggregatedTestFile)));
  if (!genericTestFile.existsSync()) {
    genericTestFile.createSync();
  }
  logger?.trace('Generating test file');

  final testDir = Directory(directoryPath);

  final importPath = _importPath(testDir, genericTestFile);
  await generator.generateTestFile(
    genericTestFile,
    testDir,
    '../${importPath.isNotEmpty ? '$importPath/' : ''}',
    hasArguments: true,
  );
  logger?.trace('Done generating test file');

  return genericTestFile.path;
}

String _importPath(Directory testDir, File aggregatedFile) {
  final dir = testDir.absolute.path.clean();
  final file = aggregatedFile.absolute.path.clean();
  final differentIndex = _compare(dir, file);

  return dir.substring(differentIndex);
}

extension on String {
  String clean() => replaceAll(r'\', '/');
}

int _compare(String first, String second) {
  final shorter = first.length >= second.length ? second : first;
  final longer = shorter == second ? first : second;
  for (var i = 0; i < shorter.length; i++) {
    if (shorter[i] != longer[i]) {
      return i;
    }
  }
  return shorter.length;
}

class TestGenerator {
  Future<void> generateTestFile(
    File genericTestFile,
    Directory testDir,
    String importPrefix, {
    @required bool hasArguments,
  }) {
    final files = testFiles(testDir, aggregatedTestFile).map((e) {
      final fromContentRoot = e.replaceFirst(testDir.path, '');
      return fromContentRoot.startsWith('/') || fromContentRoot.startsWith(r'\')
          ? fromContentRoot.substring(1)
          : fromContentRoot;
    }).toList();
    return _writeGeneratedTest(
      files,
      genericTestFile,
      importPrefix,
      hasArguments: hasArguments,
    );
  }

  List<String> testFiles(Directory testDir, String excludedFile) {
    return testDir
        .listSync(recursive: true)
        .where((file) => file.path.endsWith('_test.dart'))
        .where((file) => !file.path.endsWith(excludedFile))
        .map((file) => file.path)
        .toList(growable: false);
  }

  Future<void> _writeGeneratedTest(
    List<String> testFiles,
    File test,
    String importPrefix, {
    @required bool hasArguments,
  }) async {
    final file = test.openWrite()
      ..writeln('// ignore_for_file: directives_ordering')
      ..writeln(
        '/// This file is autogenerated and should not be committed to source control',
      )
      ..writeln('');
    for (final test in testFiles) {
      file.writeln(
          "import '$importPrefix${test.replaceAll(r'\', '/')}' as ${_importName(test)};");
    }
    file
      ..writeln('')
      ..writeln('void main(${hasArguments ? 'List<String> args' : ''}) {');
    for (final test in testFiles) {
      file.writeln(
          '  ${_importName(test)}.main(${hasArguments ? 'args' : ''});');
    }
    file.writeln('}');
    await file.close();
  }

  String _importName(String path) => path
      .replaceAll('/', '_')
      .replaceAll(r'\', '_')
      .replaceAll('_test.dart', '');
}

// Mocks generated by Mockito 5.0.0-nullsafety.7 from annotations
// in fast_flutter_driver_tool/test/update/version_test.dart.
// Do not manually edit this file.

import 'dart:async' as _i4;
import 'dart:convert' as _i5;
import 'dart:io' as _i2;
import 'dart:typed_data' as _i3;

import 'package:fast_flutter_driver_tool/src/update/path_provider_impl.dart'
    as _i6;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: comment_references
// ignore_for_file: unnecessary_parenthesis

class _FakeFile extends _i1.Fake implements _i2.File {}

class _FakeDateTime extends _i1.Fake implements DateTime {}

class _FakeRandomAccessFile extends _i1.Fake implements _i2.RandomAccessFile {}

class _FakeIOSink extends _i1.Fake implements _i2.IOSink {}

class _FakeUint8List extends _i1.Fake implements _i3.Uint8List {}

/// A class which mocks [File].
///
/// See the documentation for Mockito's code generation for more information.
class MockFile extends _i1.Mock implements _i2.File {
  MockFile() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i2.File get absolute => (super.noSuchMethod(Invocation.getter(#absolute),
      returnValue: _FakeFile()) as _i2.File);
  @override
  String get path =>
      (super.noSuchMethod(Invocation.getter(#path), returnValue: '') as String);
  @override
  _i4.Future<_i2.File> create({bool? recursive}) => (super.noSuchMethod(
      Invocation.method(#create, [], {#recursive: recursive}),
      returnValue: Future.value(_FakeFile())) as _i4.Future<_i2.File>);
  @override
  void createSync({bool? recursive}) => super.noSuchMethod(
      Invocation.method(#createSync, [], {#recursive: recursive}),
      returnValueForMissingStub: null);
  @override
  _i4.Future<_i2.File> rename(String? newPath) =>
      (super.noSuchMethod(Invocation.method(#rename, [newPath]),
          returnValue: Future.value(_FakeFile())) as _i4.Future<_i2.File>);
  @override
  _i2.File renameSync(String? newPath) =>
      (super.noSuchMethod(Invocation.method(#renameSync, [newPath]),
          returnValue: _FakeFile()) as _i2.File);
  @override
  _i4.Future<_i2.File> copy(String? newPath) =>
      (super.noSuchMethod(Invocation.method(#copy, [newPath]),
          returnValue: Future.value(_FakeFile())) as _i4.Future<_i2.File>);
  @override
  _i2.File copySync(String? newPath) =>
      (super.noSuchMethod(Invocation.method(#copySync, [newPath]),
          returnValue: _FakeFile()) as _i2.File);
  @override
  _i4.Future<int> length() =>
      (super.noSuchMethod(Invocation.method(#length, []),
          returnValue: Future.value(0)) as _i4.Future<int>);
  @override
  int lengthSync() =>
      (super.noSuchMethod(Invocation.method(#lengthSync, []), returnValue: 0)
          as int);
  @override
  _i4.Future<DateTime> lastAccessed() =>
      (super.noSuchMethod(Invocation.method(#lastAccessed, []),
          returnValue: Future.value(_FakeDateTime())) as _i4.Future<DateTime>);
  @override
  DateTime lastAccessedSync() =>
      (super.noSuchMethod(Invocation.method(#lastAccessedSync, []),
          returnValue: _FakeDateTime()) as DateTime);
  @override
  _i4.Future<dynamic> setLastAccessed(DateTime? time) =>
      (super.noSuchMethod(Invocation.method(#setLastAccessed, [time]),
          returnValue: Future.value(null)) as _i4.Future<dynamic>);
  @override
  void setLastAccessedSync(DateTime? time) =>
      super.noSuchMethod(Invocation.method(#setLastAccessedSync, [time]),
          returnValueForMissingStub: null);
  @override
  _i4.Future<DateTime> lastModified() =>
      (super.noSuchMethod(Invocation.method(#lastModified, []),
          returnValue: Future.value(_FakeDateTime())) as _i4.Future<DateTime>);
  @override
  DateTime lastModifiedSync() =>
      (super.noSuchMethod(Invocation.method(#lastModifiedSync, []),
          returnValue: _FakeDateTime()) as DateTime);
  @override
  _i4.Future<dynamic> setLastModified(DateTime? time) =>
      (super.noSuchMethod(Invocation.method(#setLastModified, [time]),
          returnValue: Future.value(null)) as _i4.Future<dynamic>);
  @override
  void setLastModifiedSync(DateTime? time) =>
      super.noSuchMethod(Invocation.method(#setLastModifiedSync, [time]),
          returnValueForMissingStub: null);
  @override
  _i4.Future<_i2.RandomAccessFile> open({_i2.FileMode? mode}) =>
      (super.noSuchMethod(Invocation.method(#open, [], {#mode: mode}),
              returnValue: Future.value(_FakeRandomAccessFile()))
          as _i4.Future<_i2.RandomAccessFile>);
  @override
  _i2.RandomAccessFile openSync({_i2.FileMode? mode}) =>
      (super.noSuchMethod(Invocation.method(#openSync, [], {#mode: mode}),
          returnValue: _FakeRandomAccessFile()) as _i2.RandomAccessFile);
  @override
  _i4.Stream<List<int>> openRead([int? start, int? end]) =>
      (super.noSuchMethod(Invocation.method(#openRead, [start, end]),
          returnValue: Stream<List<int>>.empty()) as _i4.Stream<List<int>>);
  @override
  _i2.IOSink openWrite({_i2.FileMode? mode, _i5.Encoding? encoding}) =>
      (super.noSuchMethod(
          Invocation.method(#openWrite, [], {#mode: mode, #encoding: encoding}),
          returnValue: _FakeIOSink()) as _i2.IOSink);
  @override
  _i4.Future<_i3.Uint8List> readAsBytes() =>
      (super.noSuchMethod(Invocation.method(#readAsBytes, []),
              returnValue: Future.value(_FakeUint8List()))
          as _i4.Future<_i3.Uint8List>);
  @override
  _i3.Uint8List readAsBytesSync() =>
      (super.noSuchMethod(Invocation.method(#readAsBytesSync, []),
          returnValue: _FakeUint8List()) as _i3.Uint8List);
  @override
  _i4.Future<String> readAsString({_i5.Encoding? encoding}) => (super
      .noSuchMethod(Invocation.method(#readAsString, [], {#encoding: encoding}),
          returnValue: Future.value('')) as _i4.Future<String>);
  @override
  String readAsStringSync({_i5.Encoding? encoding}) => (super.noSuchMethod(
      Invocation.method(#readAsStringSync, [], {#encoding: encoding}),
      returnValue: '') as String);
  @override
  _i4.Future<List<String>> readAsLines({_i5.Encoding? encoding}) => (super
      .noSuchMethod(Invocation.method(#readAsLines, [], {#encoding: encoding}),
          returnValue: Future.value(<String>[])) as _i4.Future<List<String>>);
  @override
  List<String> readAsLinesSync({_i5.Encoding? encoding}) => (super.noSuchMethod(
      Invocation.method(#readAsLinesSync, [], {#encoding: encoding}),
      returnValue: <String>[]) as List<String>);
  @override
  _i4.Future<_i2.File> writeAsBytes(List<int>? bytes,
          {_i2.FileMode? mode, bool? flush}) =>
      (super.noSuchMethod(
          Invocation.method(
              #writeAsBytes, [bytes], {#mode: mode, #flush: flush}),
          returnValue: Future.value(_FakeFile())) as _i4.Future<_i2.File>);
  @override
  void writeAsBytesSync(List<int>? bytes, {_i2.FileMode? mode, bool? flush}) =>
      super.noSuchMethod(
          Invocation.method(
              #writeAsBytesSync, [bytes], {#mode: mode, #flush: flush}),
          returnValueForMissingStub: null);
  @override
  _i4.Future<_i2.File> writeAsString(String? contents,
          {_i2.FileMode? mode, _i5.Encoding? encoding, bool? flush}) =>
      (super.noSuchMethod(
          Invocation.method(#writeAsString, [contents],
              {#mode: mode, #encoding: encoding, #flush: flush}),
          returnValue: Future.value(_FakeFile())) as _i4.Future<_i2.File>);
  @override
  void writeAsStringSync(String? contents,
          {_i2.FileMode? mode, _i5.Encoding? encoding, bool? flush}) =>
      super.noSuchMethod(
          Invocation.method(#writeAsStringSync, [contents],
              {#mode: mode, #encoding: encoding, #flush: flush}),
          returnValueForMissingStub: null);
}

/// A class which mocks [PathProvider].
///
/// See the documentation for Mockito's code generation for more information.
class MockPathProvider extends _i1.Mock implements _i6.PathProvider {
  MockPathProvider() {
    _i1.throwOnMissingStub(this);
  }

  @override
  String get scriptDir =>
      (super.noSuchMethod(Invocation.getter(#scriptDir), returnValue: '')
          as String);
}
